"""
Backtest Tools
=============

Scout Core Engine v6.0 i√ßin backtesting ara√ßlarƒ±
"""

import pandas as pd
import numpy as np
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
import json
from dataclasses import dataclass
from collections import defaultdict


@dataclass
class BacktestResult:
    """
    Backtest sonucu veri sƒ±nƒ±fƒ±
    """
    total_signals: int
    successful_signals: int
    failed_signals: int
    win_rate: float
    total_profit: float
    avg_profit_per_signal: float
    max_drawdown: float
    sharpe_ratio: float
    market_performance: Dict[str, Dict]
    confidence_analysis: Dict[str, float]
    time_analysis: Dict[str, float]
    league_analysis: Dict[str, Dict]


class BacktestEngine:
    """
    Backtesting motoru
    """
    
    def __init__(self, config):
        self.config = config
        self.logger = logging.getLogger("backtest")
        
        # Backtest parametreleri
        self.default_stake = 10.0  # Default bahis miktarƒ±
        self.commission_rate = 0.05  # %5 komisyon
        
        # Sonu√ßlar
        self.results = []
        self.trades = []
        self.equity_curve = []
    
    def run_backtest(self, 
                    signals_data: List[Dict], 
                    results_data: List[Dict],
                    start_date: Optional[datetime] = None,
                    end_date: Optional[datetime] = None) -> BacktestResult:
        """
        Backtest √ßalƒ±≈ütƒ±r
        
        Args:
            signals_data: Sinyal verileri
            results_data: Sonu√ß verileri
            start_date: Ba≈ülangƒ±√ß tarihi
            end_date: Biti≈ü tarihi
            
        Returns:
            Backtest sonucu
        """
        try:
            self.logger.info("üîÑ Backtest ba≈ülatƒ±lƒ±yor...")
            
            # Veriyi filtrele
            filtered_signals = self._filter_signals_by_date(signals_data, start_date, end_date)
            
            # Sinyalleri sonu√ßlarla e≈üle≈ütir
            matched_data = self._match_signals_with_results(filtered_signals, results_data)
            
            # Backtest hesaplamalarƒ±
            backtest_result = self._calculate_backtest_metrics(matched_data)
            
            self.logger.info(f"‚úÖ Backtest tamamlandƒ± - Win Rate: {backtest_result.win_rate:.2%}")
            
            return backtest_result
            
        except Exception as e:
            self.logger.error(f"‚ùå Backtest hatasƒ±: {e}")
            raise
    
    def _filter_signals_by_date(self, signals: List[Dict], 
                               start_date: Optional[datetime], 
                               end_date: Optional[datetime]) -> List[Dict]:
        """Sinyalleri tarihe g√∂re filtrele"""
        if not start_date and not end_date:
            return signals
        
        filtered = []
        for signal in signals:
            signal_date = signal.get('created_at')
            if isinstance(signal_date, str):
                signal_date = datetime.fromisoformat(signal_date)
            
            if start_date and signal_date < start_date:
                continue
            if end_date and signal_date > end_date:
                continue
                
            filtered.append(signal)
        
        return filtered
    
    def _match_signals_with_results(self, signals: List[Dict], 
                                   results: List[Dict]) -> List[Dict]:
        """Sinyalleri sonu√ßlarla e≈üle≈ütir"""
        matched = []
        
        # Sonu√ßlarƒ± match_id'ye g√∂re indexle
        results_by_match = {}
        for result in results:
            match_id = result.get('match_id')
            if match_id:
                results_by_match[match_id] = result
        
        for signal in signals:
            match_id = signal.get('match_id')
            
            if match_id in results_by_match:
                match_result = results_by_match[match_id]
                
                # Sinyal sonucunu hesapla
                outcome = self._evaluate_signal_outcome(signal, match_result)
                
                matched_signal = signal.copy()
                matched_signal.update({
                    'match_result': match_result,
                    'outcome': outcome['success'],
                    'profit': outcome['profit'],
                    'odds': outcome.get('odds', 1.0)
                })
                
                matched.append(matched_signal)
        
        return matched
    
    def _evaluate_signal_outcome(self, signal: Dict, match_result: Dict) -> Dict:
        """Sinyal sonucunu deƒüerlendir"""
        try:
            market = signal.get('market')
            selection = signal.get('selection')
            
            # Market tipine g√∂re sonu√ß kontrol√º
            if market == 'over_1_5':
                total_goals = match_result.get('total_goals', 0)
                success = total_goals > 1.5 if selection == 'over' else total_goals <= 1.5
                
            elif market == 'over_2_5':
                total_goals = match_result.get('total_goals', 0)
                success = total_goals > 2.5 if selection == 'over' else total_goals <= 2.5
                
            elif market == 'btts':
                home_goals = match_result.get('home_goals', 0)
                away_goals = match_result.get('away_goals', 0)
                both_scored = home_goals > 0 and away_goals > 0
                success = both_scored if selection == 'yes' else not both_scored
                
            elif market == 'next_goal':
                # Bu daha karma≈üƒ±k - event timeline'ƒ± gerekir
                success = self._evaluate_next_goal(signal, match_result)
                
            elif market.startswith('total_corners'):
                total_corners = match_result.get('total_corners', 0)
                line = float(market.split('_')[-1])
                success = total_corners > line if selection == 'over' else total_corners <= line
                
            elif market.startswith('total_cards'):
                total_cards = match_result.get('total_cards', 0)
                line = float(market.split('_')[-1])
                success = total_cards > line if selection == 'over' else total_cards <= line
                
            else:
                # Bilinmeyen market
                success = False
            
            # Kar/zarar hesapla
            odds = self._get_estimated_odds(signal)
            stake = self.default_stake
            
            if success:
                profit = stake * (odds - 1) - (stake * self.commission_rate)
            else:
                profit = -stake
            
            return {
                'success': success,
                'profit': profit,
                'odds': odds,
                'stake': stake
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Sinyal deƒüerlendirme hatasƒ±: {e}")
            return {'success': False, 'profit': -self.default_stake, 'odds': 1.0}
    
    def _evaluate_next_goal(self, signal: Dict, match_result: Dict) -> bool:
        """Next Goal sinyalini deƒüerlendir"""
        try:
            # Bu fonksiyon event timeline verisi gerektirir
            # ≈ûimdilik basit bir yakla≈üƒ±m kullanƒ±yoruz
            
            selection = signal.get('selection')  # 'home' veya 'away'
            
            # Ma√ß sonucuna g√∂re basit deƒüerlendirme
            home_goals = match_result.get('home_goals', 0)
            away_goals = match_result.get('away_goals', 0)
            
            if selection == 'home':
                return home_goals > away_goals
            elif selection == 'away':
                return away_goals > home_goals
            else:
                return False
                
        except Exception:
            return False
    
    def _get_estimated_odds(self, signal: Dict) -> float:
        """Tahmini oran hesapla"""
        try:
            confidence = signal.get('confidence', 0.5)
            market = signal.get('market')
            
            # Market tipine g√∂re base odds
            base_odds = {
                'over_1_5': 1.3,
                'over_2_5': 1.8,
                'over_3_5': 2.5,
                'under_2_5': 2.2,
                'btts_yes': 1.7,
                'btts_no': 2.1,
                'next_goal_home': 1.9,
                'next_goal_away': 1.9,
                'total_corners_over_9_5': 1.8,
                'total_cards_over_3_5': 1.6
            }
            
            # Market key olu≈ütur
            selection = signal.get('selection', '')
            market_key = f"{market}_{selection}" if selection else market
            
            estimated_odds = base_odds.get(market_key, 2.0)
            
            # Confidence'a g√∂re ayarla
            if confidence > 0.8:
                estimated_odds *= 0.9  # Y√ºksek g√ºven = d√º≈ü√ºk oran
            elif confidence < 0.6:
                estimated_odds *= 1.1  # D√º≈ü√ºk g√ºven = y√ºksek oran
            
            return max(1.01, estimated_odds)
            
        except Exception:
            return 2.0
    
    def _calculate_backtest_metrics(self, matched_data: List[Dict]) -> BacktestResult:
        """Backtest metriklerini hesapla"""
        try:
            if not matched_data:
                return self._empty_backtest_result()
            
            # Temel istatistikler
            total_signals = len(matched_data)
            successful_signals = sum(1 for signal in matched_data if signal.get('outcome', False))
            failed_signals = total_signals - successful_signals
            win_rate = successful_signals / total_signals if total_signals > 0 else 0
            
            # Kar/zarar analizi
            profits = [signal.get('profit', 0) for signal in matched_data]
            total_profit = sum(profits)
            avg_profit_per_signal = total_profit / total_signals if total_signals > 0 else 0
            
            # Equity curve ve drawdown
            equity_curve = np.cumsum(profits)
            max_drawdown = self._calculate_max_drawdown(equity_curve)
            
            # Sharpe ratio
            sharpe_ratio = self._calculate_sharpe_ratio(profits)
            
            # Market analizi
            market_performance = self._analyze_market_performance(matched_data)
            
            # Confidence analizi
            confidence_analysis = self._analyze_confidence_performance(matched_data)
            
            # Zaman analizi
            time_analysis = self._analyze_time_performance(matched_data)
            
            # Lig analizi
            league_analysis = self._analyze_league_performance(matched_data)
            
            return BacktestResult(
                total_signals=total_signals,
                successful_signals=successful_signals,
                failed_signals=failed_signals,
                win_rate=win_rate,
                total_profit=total_profit,
                avg_profit_per_signal=avg_profit_per_signal,
                max_drawdown=max_drawdown,
                sharpe_ratio=sharpe_ratio,
                market_performance=market_performance,
                confidence_analysis=confidence_analysis,
                time_analysis=time_analysis,
                league_analysis=league_analysis
            )
            
        except Exception as e:
            self.logger.error(f"‚ùå Backtest metrikleri hesaplama hatasƒ±: {e}")
            return self._empty_backtest_result()
    
    def _calculate_max_drawdown(self, equity_curve: np.ndarray) -> float:
        """Maksimum drawdown hesapla"""
        try:
            if len(equity_curve) == 0:
                return 0.0
            
            peak = np.maximum.accumulate(equity_curve)
            drawdown = (equity_curve - peak) / peak
            return abs(np.min(drawdown))
            
        except Exception:
            return 0.0
    
    def _calculate_sharpe_ratio(self, profits: List[float]) -> float:
        """Sharpe ratio hesapla"""
        try:
            if len(profits) < 2:
                return 0.0
            
            mean_return = np.mean(profits)
            std_return = np.std(profits)
            
            if std_return == 0:
                return 0.0
            
            # Risk-free rate'i 0 kabul ediyoruz
            sharpe = mean_return / std_return
            
            # Annualize (g√ºnl√ºk i≈ülem varsayƒ±mƒ±)
            return sharpe * np.sqrt(365)
            
        except Exception:
            return 0.0
    
    def _analyze_market_performance(self, data: List[Dict]) -> Dict[str, Dict]:
        """Market bazlƒ± performans analizi"""
        market_stats = defaultdict(lambda: {'wins': 0, 'total': 0, 'profit': 0.0})
        
        for signal in data:
            market = signal.get('market', 'unknown')
            outcome = signal.get('outcome', False)
            profit = signal.get('profit', 0)
            
            market_stats[market]['total'] += 1
            market_stats[market]['profit'] += profit
            
            if outcome:
                market_stats[market]['wins'] += 1
        
        # Win rate ve avg profit hesapla
        result = {}
        for market, stats in market_stats.items():
            result[market] = {
                'win_rate': stats['wins'] / stats['total'] if stats['total'] > 0 else 0,
                'total_signals': stats['total'],
                'total_profit': stats['profit'],
                'avg_profit': stats['profit'] / stats['total'] if stats['total'] > 0 else 0
            }
        
        return result
    
    def _analyze_confidence_performance(self, data: List[Dict]) -> Dict[str, float]:
        """Confidence seviyesi bazlƒ± performans analizi"""
        confidence_ranges = {
            'low': (0.0, 0.6),
            'medium': (0.6, 0.75),
            'high': (0.75, 1.0)
        }
        
        range_stats = defaultdict(lambda: {'wins': 0, 'total': 0})
        
        for signal in data:
            confidence = signal.get('confidence', 0.5)
            outcome = signal.get('outcome', False)
            
            for range_name, (min_conf, max_conf) in confidence_ranges.items():
                if min_conf <= confidence < max_conf:
                    range_stats[range_name]['total'] += 1
                    if outcome:
                        range_stats[range_name]['wins'] += 1
                    break
        
        # Win rate hesapla
        result = {}
        for range_name, stats in range_stats.items():
            result[f'{range_name}_confidence_win_rate'] = (
                stats['wins'] / stats['total'] if stats['total'] > 0 else 0
            )
        
        return result
    
    def _analyze_time_performance(self, data: List[Dict]) -> Dict[str, float]:
        """Zaman bazlƒ± performans analizi"""
        time_stats = defaultdict(lambda: {'wins': 0, 'total': 0})
        
        for signal in data:
            created_at = signal.get('created_at')
            outcome = signal.get('outcome', False)
            
            if isinstance(created_at, str):
                created_at = datetime.fromisoformat(created_at)
            
            if created_at:
                hour = created_at.hour
                
                # Zaman dilimlerini belirle
                if 6 <= hour < 12:
                    time_period = 'morning'
                elif 12 <= hour < 18:
                    time_period = 'afternoon'
                elif 18 <= hour < 24:
                    time_period = 'evening'
                else:
                    time_period = 'night'
                
                time_stats[time_period]['total'] += 1
                if outcome:
                    time_stats[time_period]['wins'] += 1
        
        # Win rate hesapla
        result = {}
        for period, stats in time_stats.items():
            result[f'{period}_win_rate'] = (
                stats['wins'] / stats['total'] if stats['total'] > 0 else 0
            )
        
        return result
    
    def _analyze_league_performance(self, data: List[Dict]) -> Dict[str, Dict]:
        """Lig bazlƒ± performans analizi"""
        league_stats = defaultdict(lambda: {'wins': 0, 'total': 0, 'profit': 0.0})
        
        for signal in data:
            league_id = signal.get('league_id', 'unknown')
            outcome = signal.get('outcome', False)
            profit = signal.get('profit', 0)
            
            league_stats[league_id]['total'] += 1
            league_stats[league_id]['profit'] += profit
            
            if outcome:
                league_stats[league_id]['wins'] += 1
        
        # Sonu√ßlarƒ± formatla
        result = {}
        for league_id, stats in league_stats.items():
            result[str(league_id)] = {
                'win_rate': stats['wins'] / stats['total'] if stats['total'] > 0 else 0,
                'total_signals': stats['total'],
                'total_profit': stats['profit']
            }
        
        return result
    
    def _empty_backtest_result(self) -> BacktestResult:
        """Bo≈ü backtest sonucu"""
        return BacktestResult(
            total_signals=0,
            successful_signals=0,
            failed_signals=0,
            win_rate=0.0,
            total_profit=0.0,
            avg_profit_per_signal=0.0,
            max_drawdown=0.0,
            sharpe_ratio=0.0,
            market_performance={},
            confidence_analysis={},
            time_analysis={},
            league_analysis={}
        )
    
    def generate_report(self, result: BacktestResult) -> str:
        """Backtest raporu olu≈ütur"""
        try:
            report = []
            report.append("=" * 60)
            report.append("SCOUT CORE ENGINE v6.0 - BACKTEST RAPORU")
            report.append("=" * 60)
            report.append("")
            
            # Genel istatistikler
            report.append("üìä GENEL ƒ∞STATƒ∞STƒ∞KLER")
            report.append("-" * 30)
            report.append(f"Toplam Sinyal: {result.total_signals}")
            report.append(f"Ba≈üarƒ±lƒ± Sinyal: {result.successful_signals}")
            report.append(f"Ba≈üarƒ±sƒ±z Sinyal: {result.failed_signals}")
            report.append(f"Ba≈üarƒ± Oranƒ±: {result.win_rate:.2%}")
            report.append(f"Toplam Kar: {result.total_profit:.2f}")
            report.append(f"Ortalama Kar/Sinyal: {result.avg_profit_per_signal:.2f}")
            report.append(f"Maksimum Drawdown: {result.max_drawdown:.2%}")
            report.append(f"Sharpe Ratio: {result.sharpe_ratio:.2f}")
            report.append("")
            
            # Market performansƒ±
            if result.market_performance:
                report.append("üéØ MARKET PERFORMANSI")
                report.append("-" * 30)
                for market, stats in result.market_performance.items():
                    report.append(
                        f"{market}: {stats['win_rate']:.2%} "
                        f"({stats['total_signals']} sinyal, "
                        f"{stats['total_profit']:.2f} kar)"
                    )
                report.append("")
            
            # Confidence analizi
            if result.confidence_analysis:
                report.append("üéØ CONFIDENCE ANALƒ∞Zƒ∞")
                report.append("-" * 30)
                for key, value in result.confidence_analysis.items():
                    report.append(f"{key}: {value:.2%}")
                report.append("")
            
            # Zaman analizi
            if result.time_analysis:
                report.append("‚è∞ ZAMAN ANALƒ∞Zƒ∞")
                report.append("-" * 30)
                for key, value in result.time_analysis.items():
                    report.append(f"{key}: {value:.2%}")
                report.append("")
            
            # Lig analizi (en iyi 5)
            if result.league_analysis:
                report.append("üèÜ Lƒ∞G PERFORMANSI (En ƒ∞yi 5)")
                report.append("-" * 30)
                
                # Win rate'e g√∂re sƒ±rala
                sorted_leagues = sorted(
                    result.league_analysis.items(),
                    key=lambda x: x[1]['win_rate'],
                    reverse=True
                )[:5]
                
                for league_id, stats in sorted_leagues:
                    report.append(
                        f"Lig {league_id}: {stats['win_rate']:.2%} "
                        f"({stats['total_signals']} sinyal)"
                    )
                report.append("")
            
            report.append("=" * 60)
            
            return "\n".join(report)
            
        except Exception as e:
            self.logger.error(f"‚ùå Rapor olu≈üturma hatasƒ±: {e}")
            return "Rapor olu≈üturulamadƒ±"
    
    def save_results_to_file(self, result: BacktestResult, filename: str):
        """Sonu√ßlarƒ± dosyaya kaydet"""
        try:
            # JSON formatƒ±nda kaydet
            result_dict = {
                'timestamp': datetime.now().isoformat(),
                'total_signals': result.total_signals,
                'successful_signals': result.successful_signals,
                'failed_signals': result.failed_signals,
                'win_rate': result.win_rate,
                'total_profit': result.total_profit,
                'avg_profit_per_signal': result.avg_profit_per_signal,
                'max_drawdown': result.max_drawdown,
                'sharpe_ratio': result.sharpe_ratio,
                'market_performance': result.market_performance,
                'confidence_analysis': result.confidence_analysis,
                'time_analysis': result.time_analysis,
                'league_analysis': result.league_analysis
            }
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(result_dict, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"‚úÖ Backtest sonu√ßlarƒ± kaydedildi: {filename}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Sonu√ß kaydetme hatasƒ±: {e}")


# Utility functions
def load_signals_from_file(filename: str) -> List[Dict]:
    """Dosyadan sinyal verilerini y√ºkle"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        logging.error(f"‚ùå Sinyal dosyasƒ± y√ºkleme hatasƒ±: {e}")
        return []


def load_results_from_file(filename: str) -> List[Dict]:
    """Dosyadan sonu√ß verilerini y√ºkle"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        logging.error(f"‚ùå Sonu√ß dosyasƒ± y√ºkleme hatasƒ±: {e}")
        return []