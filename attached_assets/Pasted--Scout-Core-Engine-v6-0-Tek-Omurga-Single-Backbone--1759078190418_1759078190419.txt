"""
Scout Core Engine v6.0 - Tek Omurga (Single Backbone)
====================================================

Ana motor: TÃ¼m veri saÄŸlayÄ±cÄ±larÄ± ve karar modÃ¼llerini koordine eder.
Tek Ã§Ä±ktÄ±: Final sinyal listesi
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import json

# Local imports
from data_providers.sm_client import SportMonksClient
from data_providers.fs_client import FootyStatsClient
from decision_engines.market_selector import MarketSelector
from decision_engines.rl_agent import RLAgent
from utils.config import Config
from utils.logger import setup_logger


class ScoutCoreEngine:
    """
    Scout'un tek omurgasÄ± - tÃ¼m bileÅŸenleri koordine eden ana motor
    """
    
    def __init__(self, config_path: str = "config.json"):
        """
        Core Engine'i baÅŸlat
        
        Args:
            config_path: KonfigÃ¼rasyon dosyasÄ± yolu
        """
        self.config = Config(config_path)
        self.logger = setup_logger("scout_core", self.config.log_level)
        
        # Veri saÄŸlayÄ±cÄ±larÄ±
        self.sm_client = SportMonksClient(
            api_key=self.config.sportmonks_api_key,
            base_url=self.config.sportmonks_base_url
        )
        
        self.fs_client = FootyStatsClient(
            api_key=self.config.footystats_api_key,
            base_url=self.config.footystats_base_url
        )
        
        # Karar motorlarÄ±
        self.market_selector = MarketSelector(config=self.config)
        self.rl_agent = RLAgent(config=self.config)
        
        # Engine durumu
        self.is_running = False
        self.last_update = None
        self.active_matches = {}
        self.generated_signals = []
        
        self.logger.info("ğŸš€ Scout Core Engine v6.0 baÅŸlatÄ±ldÄ±")
    
    async def start_engine(self):
        """
        Ana motoru baÅŸlat - sÃ¼rekli Ã§alÄ±ÅŸan ana dÃ¶ngÃ¼
        """
        self.is_running = True
        self.logger.info("âš¡ Core Engine baÅŸlatÄ±lÄ±yor...")
        
        try:
            while self.is_running:
                await self._main_loop()
                await asyncio.sleep(self.config.update_interval)
                
        except Exception as e:
            self.logger.error(f"âŒ Core Engine hatasÄ±: {e}")
            raise
        finally:
            self.is_running = False
            self.logger.info("ğŸ›‘ Core Engine durduruldu")
    
    async def stop_engine(self):
        """
        Ana motoru durdur
        """
        self.logger.info("ğŸ›‘ Core Engine durduruluyor...")
        self.is_running = False
    
    async def _main_loop(self):
        """
        Ana iÅŸlem dÃ¶ngÃ¼sÃ¼ - tek omurga mantÄ±ÄŸÄ±
        """
        try:
            # 1. CanlÄ± maÃ§larÄ± al
            live_matches = await self._get_live_matches()
            
            if not live_matches:
                self.logger.debug("ğŸ“Š Aktif canlÄ± maÃ§ bulunamadÄ±")
                return
            
            # 2. Her maÃ§ iÃ§in sinyal Ã¼retim sÃ¼reci
            new_signals = []
            
            for match in live_matches:
                match_signals = await self._process_match(match)
                new_signals.extend(match_signals)
            
            # 3. Sinyalleri gÃ¼ncelle
            self._update_signals(new_signals)
            
            # 4. Durum gÃ¼ncelle
            self.last_update = datetime.now()
            self.active_matches = {m['id']: m for m in live_matches}
            
            self.logger.info(f"ğŸ”„ Engine dÃ¶ngÃ¼sÃ¼ tamamlandÄ± - {len(new_signals)} yeni sinyal")
            
        except Exception as e:
            self.logger.error(f"âŒ Ana dÃ¶ngÃ¼ hatasÄ±: {e}")
    
    async def _get_live_matches(self) -> List[Dict]:
        """
        CanlÄ± maÃ§larÄ± SportMonks'tan al
        """
        try:
            # SportMonks Advanced - canlÄ± maÃ§lar
            live_matches = await self.sm_client.get_live_matches()
            
            # Sadece desteklenen liglerdeki maÃ§larÄ± filtrele
            filtered_matches = [
                match for match in live_matches 
                if match.get('league_id') in self.config.supported_leagues
            ]
            
            self.logger.debug(f"ğŸ“Š {len(filtered_matches)} canlÄ± maÃ§ bulundu")
            return filtered_matches
            
        except Exception as e:
            self.logger.error(f"âŒ CanlÄ± maÃ§ verisi alÄ±namadÄ±: {e}")
            return []
    
    async def _process_match(self, match: Dict) -> List[Dict]:
        """
        Tek maÃ§ iÃ§in sinyal Ã¼retim sÃ¼reci
        
        Args:
            match: MaÃ§ verisi
            
        Returns:
            Bu maÃ§ iÃ§in Ã¼retilen sinyaller
        """
        match_id = match['id']
        
        try:
            # 1. DetaylÄ± maÃ§ verisi al (SportMonks Advanced)
            match_data = await self.sm_client.get_match_details(match_id)
            
            # 2. Pre-match trend verileri al (FootyStats)
            trend_data = await self.fs_client.get_match_trends(match_id)
            
            # 3. Veri birleÅŸtirme
            combined_data = {
                'match': match_data,
                'trends': trend_data,
                'timestamp': datetime.now()
            }
            
            # 4. Market seÃ§imi - hangi marketlerde sinyal aranacak
            candidate_markets = await self.market_selector.select_markets(combined_data)
            
            if not candidate_markets:
                return []
            
            # 5. RL Agent - final sinyal kararÄ±
            final_signals = await self.rl_agent.generate_signals(
                combined_data, 
                candidate_markets
            )
            
            self.logger.debug(f"ğŸ¯ MaÃ§ {match_id}: {len(final_signals)} sinyal Ã¼retildi")
            return final_signals
            
        except Exception as e:
            self.logger.error(f"âŒ MaÃ§ {match_id} iÅŸlenemedi: {e}")
            return []
    
    def _update_signals(self, new_signals: List[Dict]):
        """
        Sinyal listesini gÃ¼ncelle
        
        Args:
            new_signals: Yeni Ã¼retilen sinyaller
        """
        # Eski sinyalleri temizle (expired olanlar)
        current_time = datetime.now()
        
        self.generated_signals = [
            signal for signal in self.generated_signals
            if current_time - signal['created_at'] < timedelta(minutes=self.config.signal_ttl)
        ]
        
        # Yeni sinyalleri ekle
        for signal in new_signals:
            signal['created_at'] = current_time
            signal['status'] = 'active'
        
        self.generated_signals.extend(new_signals)
        
        self.logger.info(f"ğŸ“Š Toplam aktif sinyal: {len(self.generated_signals)}")
    
    def get_active_signals(self) -> List[Dict]:
        """
        Aktif sinyalleri dÃ¶ndÃ¼r - API ve Dashboard iÃ§in
        
        Returns:
            Aktif sinyal listesi
        """
        return [
            signal for signal in self.generated_signals
            if signal['status'] == 'active'
        ]
    
    def get_engine_status(self) -> Dict:
        """
        Engine durumu - monitoring iÃ§in
        
        Returns:
            Engine durum bilgileri
        """
        return {
            'is_running': self.is_running,
            'last_update': self.last_update.isoformat() if self.last_update else None,
            'active_matches_count': len(self.active_matches),
            'active_signals_count': len(self.get_active_signals()),
            'total_signals_generated': len(self.generated_signals),
            'uptime': (datetime.now() - self.last_update).total_seconds() if self.last_update else 0
        }
    
    async def manual_signal_generation(self, match_id: int) -> List[Dict]:
        """
        Manuel sinyal Ã¼retimi - test ve debug iÃ§in
        
        Args:
            match_id: MaÃ§ ID'si
            
        Returns:
            Ãœretilen sinyaller
        """
        try:
            # MaÃ§ verisini al
            match_data = await self.sm_client.get_match_details(match_id)
            
            if not match_data:
                return []
            
            # Sinyal Ã¼retim sÃ¼recini Ã§alÄ±ÅŸtÄ±r
            signals = await self._process_match({'id': match_id})
            
            self.logger.info(f"ğŸ”§ Manuel sinyal Ã¼retimi - MaÃ§ {match_id}: {len(signals)} sinyal")
            return signals
            
        except Exception as e:
            self.logger.error(f"âŒ Manuel sinyal Ã¼retimi hatasÄ±: {e}")
            return []


# Async context manager iÃ§in
class ScoutEngineManager:
    """
    Scout Engine'i yÃ¶netmek iÃ§in context manager
    """
    
    def __init__(self, config_path: str = "config.json"):
        self.engine = ScoutCoreEngine(config_path)
    
    async def __aenter__(self):
        return self.engine
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.engine.stop_engine()


# CLI iÃ§in basit baÅŸlatma
async def main():
    """
    CLI'dan engine baÅŸlatma
    """
    async with ScoutEngineManager() as engine:
        print("ğŸš€ Scout Core Engine v6.0 baÅŸlatÄ±lÄ±yor...")
        await engine.start_engine()


if __name__ == "__main__":
    asyncio.run(main())